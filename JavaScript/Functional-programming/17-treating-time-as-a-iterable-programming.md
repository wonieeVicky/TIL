## 시간을 이터러블로 다루기

### range와 take의 재해석

range와 take 함수는 아래와 같은 일을 도출해낸다.

```jsx
_.go(
  _.range(10), // 0부터 9까지의 배열
  _.take(3), // 앞에서 3개만 자르기
  console.log
); // [0, 1, 2]
```

위 함수를 이터러블로 다루면 아래와 같이 할 수 있다.

```jsx
_.go(
  L.range(10), // 0부터 9까지의 이터러블, 최대 10번 일어날 일이 예약된다. 10개의 배열을 만들겠다가 아닌 계획을 의미함
  L.take(3), // 최대 3개의 값을 필요로 하고, 최대 3번의 일을 수행한다.
  console.log
); // takeLazy{<suspended>}
```

위 range와 take의 함수는 성격이 약간 다르다.

```jsx
_.go(
  L.range(Infinity), // 몇 번 일어날지는 알 수 없다.
  L.take(3), // 최대 3개의 값을 필요로하고, 최대 3번의 일을 수행하도록 최적화 한다.
  _.each(console.log)
); // 0, 1, 2
```

만약 range함수에 Infinity가 들어가게 된다면, 몇 번 일어날지 알수 없으며, 그러한 값에 take 함수로 3번의 제한을 두게되는 프로그래밍을 할 수 있게 된다. 실제 console.log로 찍히는 값은 일반 함수나 지연평가 함수나 똑같기 때문에 크게 와닿지 않을 수 있으나, 지연평가의 경우 실행의 흐름이 수직으로 흐르기 때문에, `L.range(1) → L.take(1) → console.log → L.range(2) → L.take(2) → console.log → ...` 훨씬 효율적이라고 볼 수 있다.

```jsx
_.go(
  L.range(1, 10),
  L.map(_.delay(1000)),
  L.filter((a) => a % 2),
  L.map((_) => new Date()),
  L.take(3),
  _.each(console.log)
);
// Sat Feb 05 2022 23:42:01 GMT+0900 (한국 표준시)
// Sat Feb 05 2022 23:42:03 GMT+0900 (한국 표준시)
// Sat Feb 05 2022 23:42:05 GMT+0900 (한국 표준시)
```

위 코드처럼 시점을 이터러블 프로그래밍 사고로 바라보면 시점에 따른 다양한 액션을 구현할 수 있으므로, 더 많은 로직을 구성하고 만드는 언어로서 핸들링할 수 있게 된다.
