# 비동기: 동시성 프로그래밍

### callback과 Promise

자바스크립트에서 비동기 동시성 프로그래밍을 하는 방법은 크게 두가지가 있다. 오랫동안 사용되어 왔던 콜백 패턴과 Promise를 기반으로 함수를 합성하는 방법, Promise에서 발전된 async ~ await으로 구현하는 방법이다.

먼저 콜백방식에 대해 살펴보고 Promise와 콜백 방법의 차이점, 함수형 프로그래밍과 Promise와의 조합에 대해 논해보자

먼저 콜백패턴에 대해 알아보자 add10 함수는 100ms 이후에 동작을 실행하는 함수를 만들고자 한다.

```jsx
function add10(a, callback) {
  setTimeout(() => callback(a + 10), 100);
}
add10(5, (res) => {
  add10(res, (res) => {
    add10(res, (res) => {
      log(res);
    });
  });
}); // 300ms 후 35
```

위 함수를 Promise를 통해 구현하면 아래와 같다.

```jsx
function add20(a) {
  return new Promise((resolve) => setTimeout(() => resolve(a + 20), 100));
}
add20(5).then(add20).then(add20).then(log); // 300ms 후 65
```

같은 기능을 하는 함수를 콜백함수와 Promise로 나누어 구현했을 때 콜백함수의 경우 함수 내 중첩 함수가 많아져 Promise 구조에 비해 복잡하여 가독성이 떨어지는 것을 알 수 있다.

### 비동기를 값으로 만드는 Promise

Promise와 콜백은 사용 시 구조의 차이도 있지만 가장 중요한 차이는 어떻게 결과를 꺼내어 보느냐가 아니다. (즉, 콜백지옥과 then으로 가독성 높게 보는 것이 중요한 것이 아니다.)

Promise와 콜백함수의 가장 중요한 차이는 비동기 상황을 일급 값으로 다룬다는 점이다. Promise는 Promise라는 클래스를 통해 만들어진 인스턴스를 반환하는데, 그 반환값은 `대기`, `성공`, `실패`를 다루는 일급 값으로 이루어져 있다. 즉, "대기되어지고 있다"는 값을 만든다는 점에서 콜백과 큰 차이를 가지는 것이다.

이 점을 정확히 떠올리면서 프로그래밍을 할 줄 알면 그에 따른 응용할 수 있는 아이디어가 많아지므로 주의깊게 살펴볼 필요가 있다. 위 add20 함수의 경우 비동기 상황에 대한 값을 만들어 리턴한다는 점이 중요한 것이다..!

위 add10과 add20에 대한 결과값을 보자

```jsx
var a = add10(5, (res) => {
  add10(res, (res) => {
    add10(res, (res) => {
      log(res);
    });
  });
});
log(a); // undefined

var b = add20(5).then(add20).then(add20).then(log); // Promise {<pending>}

add10(5, (_) => _); // undefined
add20(5, (_) => _); // Promise {<pending>}
```

add10과 Promise를 사용한 add20의 가장 큰 차이는 위와 같이 Promise에 대한 결과값을 즉시 반환한다는 점이다. 이 때문에 그 이후에 원하는 어떤 일들을 쉽게 다룰 수 있게된다. add10은 함수 실행이 끝난 후 어떤 것도 실행할 수 없지만 add20의 경우 실행이 완료된 후 원하는 일을 추가적으로 할 수 있게되는 것이다.

```jsx
var step1 = add20(5, (_) => _); // Promise {<pending>}
step1; // Promise {<resolved>: 25}
var step2 = step1.then((a) => a - 5);
step2; // Promise {<resolved>: 20}
var step3 = step2.then((a) => a * 10);
step3; // Promise {<resolved>: 200}
```

즉, 비동기로 일어난 상황에 대해 값으로 다룰 수 있고, 값으로 다룰 수 있다는 것은 즉 일급이라는 것이고, 일급이라는 것은 어떤 변수에 할당되거나, 어떤 함수에 전달되거나, 전달된 값을 가지고 yield를 이어나갈 수 있다는 것을 의미한다. 이는 매우 중요한 차이이다..! ⭐️⭐️⭐️

### 값으로서의 Promise 활용

Promise가 비동기 상황을 값으로 다루는 일급의 성질을 가지고 있다는 점을 활용해 다양한 것들을 할 수 있다.
효과적으로 코드를 정리하고 좋은 로직을 만드는데 있어서 필요한 좋은 함수를 많이 만들어볼 수 있다.

아래 예제코드를 보자

```jsx
const go1 = (a, f) => f(a);
const add5 = (a) => a + 5;

log(go1(10, add5)); // 15
```

위 `go1` 함수가 정상적으로 동작하기 위해서는 몇가지 전제 조건이 필요하다. 먼저 `f`라는 함수가 동기적으로 동작하는 함수여야 하고, a라는 값 역시 동기적으로 바로 값을 알 수 있는 상태여야 한다. 즉 비동기 상황이 일어난 일급 값이 아닌 일반 값이 들어와야 해당 함수가 정상적으로 실행될 수 있다는 것을 의미한다.

그럼 만약 해당 값이 비동기 코드로 받아오는 값이 된다면 어떻게 될까?
당연히 아래처럼 정상적인 실행이 되지 않을 것이다.

```jsx
log(go1(Promise.resolve(10), add5)); // [object Promise]5

// 100ms 후에 받은 값을 리턴하는 함수
const delay100 = (a) => new Promise((resolve) => setTimeout(() => resolve(a), 100));
log(go(delay100(10), add5)); // [object Promise]5
```

위 코드도 정상적으로 실행될 수 있도록 `go1` 함수를 다형성을 지원하도록 변경해보자

```jsx
const go1 = (a, f) => a instanceof Promise ? a.then(f) : f(a);

var r = go1(10, add5);
log(r); // 15

var r2 = go1(delay100(10), add5)); // Promise {<pending>} - [[PromiseValue]]: 15
r2.then(log); // 15
```

위와 같이 변경하면 값 15를 만들 수 있는 상태가 만들어진다. `r`과 `r2`가 동일한 역할을 하게 되는 것이다.
위 함수는 아래와 같이 리팩토링을 할 수 있다.

```jsx
go1(go1(10, add5), log); // 15
go1(go1(delay100(10), add5), log); // 15

// 혹은 아래와 같이 만들면 더 비슷해보인다.
const n1 = 10;
go1(go1(n1, add5), log); // 15
log(go1(go1(n1, add5), log)); // undefined

const n2 = delay100(10);
go1(go1(n2, add5), log); // 15
log(go1(go1(n2, add5), log)); // Promise {<pending>} : 값을 지속적으로 더 만들어나갈 수 있다. 이것이 차이점이다.
```

### 합성 관점에서의 Promise와 모나드

이번에는 함수 합성 관점에서의 Promise를 논해보자 Promise는 비동기 상황에서 함수 합성을 안전하게 하기 위한 도구라고 볼 수 있다. 비동기 값을 가지고 연속적인 함수 실행 및 합성을 안전하게 처리하는 모나드라고 할 수 있는 것이다.

자바스크립트는 동적 타입 언어이고, 타입을 중심적으로 사고하면서 프로그래밍 하는 언어가 아니기 때문에 모나드라던지 대수구조의 타입이라던지 하는 것들이 잘 뭍어나지 않는 경향이 있다. 따라서 직접적으로 모나드를 이용한 프로그래밍은 거의 이루어지지 않는다. 

그러나 모나드를 알아둘 필요가 있다. 모나드란 함수 합성을 안전하게 하기 위한 도구이다. 
아래와 같은 함수가 있다고 하자

```jsx
const g = a => a + 1;
const f = a -> a * a;

log(f(g(1))); // 4 - 정상적으로 연속적으로 매개변수가 전달됨
log(f(g())); // NaN - 매개변수에 빈 값을 주면 NaN으로 반환, 어떤 값이 들어올지 모르는 상황이 이에 속한다.
```

위 `f(g(1));` 은 대표적으로 g와 f 함수를 합성한 예시이다.  위 `f(g());` 는 매개변수의 빈 값이 들어가 NaN으로 반환되는 안전하지 않는 함수 합성 관계이며, 이 함수는 나아가 어떤 값이 들어올지 모르는 상황의 함수가 비슷하다고 볼 수 있다.

비동기 처리로 인해 어떠한 값이 들어올지 모르는 함수 합성을 어떻게하면 안전하게 할 수 있을까? 바로 모나드를 이용하면 된다. 

```jsx
// f(g(1)); 코드는 아래와 같이 구현할 수 있다.
log(Array.of(1).map(g).map(f)); // [4]
[1].map(g).map(f).forEach(r => log(r)); // 4
```

값을 배열로서 선언적으로 가지고 있는 형태로 바뀐 것이다. forEach에 따라 값이 있으면 반환하는 형식으로 바뀐 이 구조를 모나드라고 할 수 있는데, 값이 담긴 배열이 빈 배열일 경우 NaN이 아닌 코드 실행을 멈추기 때문이다.

```jsx
// (f(g()); 코드는 아래와 같이 구현할 수 있다.
[].map(g).map(f).forEach(r => log(r)); // 
```

위와 같이 배열이 비어있을 경우 함수 실행자체가 이루어지지 않는 것이다. 기존의 `f(g())`의 경우 인자의 유무에 상관없이 함수 실행이 되어버려 효과까지 가버리는 반면, 모나드 형태의 배열로 함수를 합성했을 때는 조건이 맞지 않으면 효과가 아예 발생하지 않는 구조로 바뀐 것이다. 

그렇다면 Promise는 어떠한 함수 합성을 하는 값인 것일까?

```jsx
Promise.resolve(1).then(g).then(f).then(r => log(r)); // 1
Promise.resolve(2).then(g).then(f).then(r => log(r)); // 4
Promise.resolve().then(g).then(f).then(r => log(r)); // NaN
```

```jsx
new Promise(resolve => setTimeout(() => resolve(2), 100)).then(g).then(f).then(r => log(r));
```

Promise도 어떤 특정 상황들을 안전하게 함수를 합성하기 위한 하나의 도구이고 이를 모나드라고 부른다. 합성관점에서 비동기 상황에서도 함수를 적절한 시점에 평가해서 합성시키기 위한 도구로서 Promise를 바라볼 수 있다.