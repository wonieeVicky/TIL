<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Document</title>
    <script src="./fx.js"></script>
  </head>
  <body>
    ## 객체지향과 함께 사용하기 - 사용자 정의 객체를 이터러블 프로그래밍으로
    <hr />
    ### 1. range와 take의 재해석

    <script>
      _.go(
        _.range(10), // 0부터 9까지의 배열
        _.take(3), // 앞에서 3개만 자르기
        _.each(console.log)
      ); // 0, 1, 2

      _.go(
        L.range(10), // 0부터 9까지의 이터러블, 최대 10번 일어날 일, 10개의 배열을 만들겠다가 아닌 계획을 의미함
        L.map(_.delay(1000)), // 특정 시점(1초) 뒤에 값을 넘겨준다.
        L.filter((a) => a % 2),
        L.take(3), // 최대 3개의 값을 필요로하고, 최대 3번의 일을 수행한다.
        _.each(console.log)
      ); // 1, 3, 5

      // 이처럼 시각을 다르게보면 시점을 이터러블 프로그래밍 사고로 바라보면 더 많은 것을 할 수 잇다.
      _.go(
        L.range(1, 10),
        L.map(_.delay(1000)),
        L.filter((a) => a % 2),
        L.map((_) => new Date()),
        L.take(3),
        _.each(console.log)
      );
      // L.take를 쓸면 스케줄러처럼 값이 모두 이후에 평가되도록 처리할 수 있음
      // _.take를 쓰면 앞선 일들을 모두 모아낸 후 3개를 뽑아낼 수 있음 즉, 전략적으로 코드를 만들 수 있다.

      // Sat Feb 05 2022 23:42:01 GMT+0900 (한국 표준시)
      // Sat Feb 05 2022 23:42:03 GMT+0900 (한국 표준시)
      // Sat Feb 05 2022 23:42:05 GMT+0900 (한국 표준시)

      console.clear();
    </script>

    ### 2. takewhile, takeUntil
    <script>
      // 아래처럼 어디까지 기능을 실행할 것에 따라 맞춰서 쓸 수 있음
      _.go(
        [1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0],
        L.takeWhile((a) => a), // 값이 true일 때만 전달해주는 역할을 함
        _.each(console.log)
      ); // 1, 2, 3, 4, 5, 6, 7, 8

      _.go(
        [1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0],
        L.takeUntil((a) => a), // 값이 true인 경우 멈추게된다.
        _.each(console.log)
      ); // 1

      _.go(
        [1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0],
        L.takeUntil((a) => !a),
        _.each(console.log)
      ); // 1, 2, 3, 4, 5, 6, 7, 8, 0

      _.go(
        [0, false, undefined, null, 10, 20, 30],
        _.takeUntil((a) => a),
        _.each(console.log)
      ); // 0, false, undefined, null, 10
    </script>
  </body>
</html>
