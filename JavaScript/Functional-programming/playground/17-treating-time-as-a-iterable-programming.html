<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Document</title>
    <script src="./fx.js"></script>
  </head>
  <body>
    ## 객체지향과 함께 사용하기 - 사용자 정의 객체를 이터러블 프로그래밍으로
    <hr />
    ### 1. range와 take의 재해석

    <script>
      _.go(
        _.range(10), // 0부터 9까지의 배열
        _.take(3), // 앞에서 3개만 자르기
        _.each(console.log)
      ); // 0, 1, 2

      _.go(
        L.range(10), // 0부터 9까지의 이터러블, 최대 10번 일어날 일, 10개의 배열을 만들겠다가 아닌 계획을 의미함
        L.map(_.delay(1000)), // 특정 시점(1초) 뒤에 값을 넘겨준다.
        L.filter((a) => a % 2),
        L.take(3), // 최대 3개의 값을 필요로하고, 최대 3번의 일을 수행한다.
        _.each(console.log)
      ); // 1, 3, 5

      // 이처럼 시각을 다르게보면 시점을 이터러블 프로그래밍 사고로 바라보면 더 많은 것을 할 수 잇다.
      _.go(
        L.range(1, 10),
        L.map(_.delay(1000)),
        L.filter((a) => a % 2),
        L.map((_) => new Date()),
        L.take(3),
        _.each(console.log)
      );
      // L.take를 쓸면 스케줄러처럼 값이 모두 이후에 평가되도록 처리할 수 있음
      // _.take를 쓰면 앞선 일들을 모두 모아낸 후 3개를 뽑아낼 수 있음 즉, 전략적으로 코드를 만들 수 있다.

      // Sat Feb 05 2022 23:42:01 GMT+0900 (한국 표준시)
      // Sat Feb 05 2022 23:42:03 GMT+0900 (한국 표준시)
      // Sat Feb 05 2022 23:42:05 GMT+0900 (한국 표준시)

      console.clear();
    </script>

    ### 2. takewhile, takeUntil
    <script>
      // 아래처럼 어디까지 기능을 실행할 것에 따라 맞춰서 쓸 수 있음
      _.go(
        [1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0],
        L.takeWhile((a) => a), // 값이 true일 때만 전달해주는 역할을 함
        _.each(console.log)
      ); // 1, 2, 3, 4, 5, 6, 7, 8

      _.go(
        [1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0],
        L.takeUntil((a) => a), // 값이 true인 경우 멈추게된다.
        _.each(console.log)
      ); // 1

      _.go(
        [1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0],
        L.takeUntil((a) => !a),
        _.each(console.log)
      ); // 1, 2, 3, 4, 5, 6, 7, 8, 0

      _.go(
        [0, false, undefined, null, 10, 20, 30],
        _.takeUntil((a) => a),
        _.each(console.log)
      ); // 0, false, undefined, null, 10
    </script>

    ### 3. 할 일들을 이터러블(리스트)로 바라보기
    <script>
      const track = [
        { cars: ["철수", "영희", "철희", "영수"] },
        { cars: ["하든", "커리", "듀란트", "탐슨"] },
        { cars: ["폴", "어빙", "릴라드", "맥컬럼"] },
        { cars: ["스파이더맨", "아이언맨"] },
        { cars: [] },
      ];

      _.go(
        L.range(Infinity), // 언제 끝날지는 모르지만 연속적으로 yield를 한다. (계속 리스트가 추가되는 경우)
        L.map((i) => track[i]), // 트랙을 꺼낸다.
        L.map(({ cars }) => cars), // cars 배열만 꺼낸다.
        L.map(_.delay(2000)),
        L.takeWhile(({ length: l }) => l == 4), // 길이가 4인 것만 꺼낸다.
        L.flat, // 철수, 영희, 철희, 영수.. 배열을 풀어서 반환함
        L.map((car) => `${car} 출발!`),
        _.each(console.log)
      );
      // 2초마다 하나씩 값이 나옴
      // 철수 출발!
      // 영희 출발!
      // 철희 출발!
      // 영수 출발!
      // 하든 출발!
      // 커리 출발!
      // 듀란트 출발!
      // 탐슨 출발!
      // 폴 출발!
      // 어빙 출발!
      // 릴라드 출발!
      // 맥컬럼 출발!

      _.go(
        L.range(Infinity), // 언제 끝날지는 모르지만 연속적으로 yield를 한다. (계속 리스트가 추가되는 경우)
        L.map((i) => track[i]), // 트랙을 꺼낸다.
        L.map(({ cars }) => cars), // cars 배열만 꺼낸다.
        L.map(_.delay(2000)),
        L.takeUntil(({ length: l }) => l < 4), // 길이가 4보다 처음 작을 때까지 반복한다.
        L.flat, // 철수, 영희, 철희, 영수.. 배열을 풀어서 반환함
        L.map((car) => `${car} 출발!`),
        _.each(console.log)
      );
      // 2초마다 하나씩 값이 나옴
      // 철수 출발!
      // 영희 출발!
      // 철희 출발!
      // 영수 출발!
      // 하든 출발!
      // 커리 출발!
      // 듀란트 출발!
      // 탐슨 출발!
      // 폴 출발!
      // 어빙 출발!
      // 릴라드 출발!
      // 맥컬럼 출발!
      // 스파이더맨 출발!
      // 아이언맨 출발!

      // 위처럼 대기, 조건 등에 따른 일어날 일들에 대해 다양하게 다룰 수 있다.
    </script>
  </body>
</html>
