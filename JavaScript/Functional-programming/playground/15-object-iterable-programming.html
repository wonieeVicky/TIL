<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Document</title>
    <script src="./fx.js"></script>
  </head>
  <body>
    ## 객체를 이터터블 프로그래밍으로 다루기
    <script>
      const obj1 = {
        a: 1,
        b: 2,
        c: 3,
      };
      // 이를 배열화 할 수 있는 가장 간단한 방법은
      var arr = Object.entries(obj1); // [["a", 1], ["b", 2], ["c", 3]]
      console.log(arr[Symbol.iterator]); // values(){ [native code] }
      console.log(arr[Symbol.iterator]()); // Array Iterator {}
      // 아직 평가가 마치지 않은 상태의 iterator을 만듦으로써
      // 이후 filter, take 함수를 통해 최적화를 할 수 있는 여지를 남겨놓기 위함이다.
      // 지연성과 동시성을 함께 사용할 수 있게 됨

      // 위 방법은 같은 크기의 Array를 별도로 만드는 것이므로 비효율적
      // key, value 구성의 object에 동시성, 지연성을 적용할 수 있는 이터러블 프로그래밍 방법을 알아보자
    </script>

    1. values
    <script>
      console.log(Object.values(obj1));

      L.values = function* (obj) {
        for (const k in obj) yield obj[k];
      };
      var it = L.values(obj1);
      // console.log([...it]); // [1,2,3,4]
      var it2 = L.take(2, it);
      console.log([...it2]); // [1, 2]

      // 객체의 값이 obj1과 같이 4개만 있을 때에는 지연평가로 하는 것이 차이가 없거나 혹은 비용이 더 드는 일이 될 수 있다.
      // 하지만 객체의 길이가 깊어지거나 보조함수가 하는 일이 복잡할수록 좀 더 유리한 연산이 될 수 있다.

      _.go(
        obj1,
        Object.values, // 즉시 모든 값을 배열로 변환
        _.map((a) => a + 10),
        _.reduce((a, b) => a + b),
        console.log
      );

      _.go(
        obj1,
        L.values, // 평가를 모두 하지 않고 결과를 만들어나갈 수 있음
        L.take(2), // iterable 최소화
        _.map((a) => a + 10),
        _.reduce((a, b) => a + b),
        console.log
      );
    </script>
  </body>
</html>
