<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Document</title>
    <script src="./fx.js"></script>
  </head>
  <body>
    ## 객체를 이터터블 프로그래밍으로 다루기
    <script>
      const obj1 = {
        a: 1,
        b: 2,
        c: 3,
      };
      // 이를 배열화 할 수 있는 가장 간단한 방법은
      var arr = Object.entries(obj1); // [["a", 1], ["b", 2], ["c", 3]]
      console.log(arr[Symbol.iterator]); // values(){ [native code] }
      console.log(arr[Symbol.iterator]()); // Array Iterator {}
      // 아직 평가가 마치지 않은 상태의 iterator을 만듦으로써
      // 이후 filter, take 함수를 통해 최적화를 할 수 있는 여지를 남겨놓기 위함이다.
      // 지연성과 동시성을 함께 사용할 수 있게 됨

      // 위 방법은 같은 크기의 Array를 별도로 만드는 것이므로 비효율적
      // key, value 구성의 object에 동시성, 지연성을 적용할 수 있는 이터러블 프로그래밍 방법을 알아보자
    </script>

    1. values
    <script>
      console.log(Object.values(obj1));

      L.values = function* (obj) {
        for (const k in obj) yield obj[k];
      };
      var it = L.values(obj1);
      // console.log([...it]); // [1,2,3,4]
      var it2 = L.take(2, it);
      console.log([...it2]); // [1, 2]

      // 객체의 값이 obj1과 같이 4개만 있을 때에는 지연평가로 하는 것이 차이가 없거나 혹은 비용이 더 드는 일이 될 수 있다.
      // 하지만 객체의 길이가 깊어지거나 보조함수가 하는 일이 복잡할수록 좀 더 유리한 연산이 될 수 있다.

      _.go(
        obj1,
        Object.values, // 즉시 모든 값을 배열로 변환
        _.map((a) => a + 10),
        _.reduce((a, b) => a + b),
        console.log
      );

      _.go(
        obj1,
        L.values, // 평가를 모두 하지 않고 결과를 만들어나갈 수 있음
        L.take(2), // iterable 최소화
        _.map((a) => a + 10),
        _.reduce((a, b) => a + b),
        console.log
      );
    </script>

    2. entries
    <script>
      L.entries = function* (obj) {
        for (const k in obj) {
          yield [k, obj[k]];
        }
      };
      var it = L.entries(obj1);
      console.log(it.next().value); // ["a", 1]
      console.log(it.next().value); // ["b", 2]
      console.log(it.next().value); // ["c", 3]
      console.log(it.next().value); // undefined

      _.go(obj1, L.entries, _.takeAll, console.log); // [["a", 1], ["b", 2], ["c", 3]]
      _.go(obj1, L.entries, _.take(2), console.log); // [["a", 1], ["b", 2]]
      _.go(
        obj1,
        L.entries,
        L.filter(([_, v]) => v % 2),
        L.map(([k, v]) => ({ [k]: v })),
        _.each(console.log)
      ); // {a: 1}, {c: 3}
      _.go(
        obj1,
        L.entries,
        L.filter(([_, v]) => v % 2),
        L.map(([k, v]) => ({ [k]: v })),
        _.reduce(Object.assign),
        console.log
      ); // {a: 1, c: 3}

      // 위와 같이 entries를 이터러블 프로그래밍을 하는 이유가
      // 단순히 entries를 어떻게 구현하느냐를 보여주기 위함뿐만 아니라
      // 이터러블하지 않은 값을 이터러블화하도록 변경하는 함수를 만듦으로써
      // 이후 이터러블 프로그래밍으로 만들어나갈 수 있다는 사례를 보여주는 것임
      // 주어진 값이 어떤 형태이던지, 이터러블 프로그래밍으로 구현해 나갈 수 있다.
    </script>

    3. keys
    <script>
      L.keys = function* (obj) {
        for (const k in obj) {
          yield k;
        }
      };

      _.go(obj1, L.keys, _.each(console.log)); // a, b, c
    </script>
  </body>
</html>
